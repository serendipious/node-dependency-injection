// Generated by CoffeeScript 1.7.1
(function() {
  var Assert, DependencyInjection, _;

  _ = require('underscore');

  Assert = require('assert');

  DependencyInjection = (function() {
    function DependencyInjection(options) {
      var debug, dependants, dependencies;
      if (options == null) {
        options = {};
      }
      debug = options.debug, dependencies = options.dependencies, dependants = options.dependants;
      this.debug = debug || false;
      this.dependencies = dependencies || {};
      this.dependants = dependants || {};
    }

    DependencyInjection.prototype.log = function() {
      arguments[0] = '[DependencyInjection] ' + arguments[0];
      if (this.debug) {
        return console.log.apply(console, arguments);
      }
    };

    DependencyInjection.prototype.register = function(dependency_key, dependency_value) {
      this.log('register', arguments);
      Assert.ok(typeof dependency_key === 'string' && dependency_key.length > 0, 'Dependency name/key has to be passed as a non-empty string');
      Assert.ok(dependency_value != null, 'Dependency (value) is required');
      this.dependencies[dependency_key] = dependency_value;
      return this.inject([dependency_key]);
    };

    DependencyInjection.prototype.resolve = function(dependencies, resolver) {
      var dependency, _i, _len;
      this.log('resolve', dependencies);
      Assert.ok(dependencies instanceof Array && dependencies.length > 0, 'Dependencies have to be a non-empty list of dependencies');
      Assert.ok(resolver instanceof Function, 'Resolver has to be a function');
      for (_i = 0, _len = dependencies.length; _i < _len; _i++) {
        dependency = dependencies[_i];
        this.dependants[dependency] = this.dependants[dependency] || [];
        resolver.dependencies = dependencies;
        this.log('resolver dependencies', resolver.dependencies);
        this.dependants[dependency].push(resolver);
      }
      return this.inject(dependencies);
    };

    DependencyInjection.prototype.inject = function(dependencies) {
      var dependency, resolved, resolver, resolver_context, resolver_dependencies, resolver_dependency, resolver_dependency_name, resolvers, _i, _j, _k, _len, _len1, _len2, _ref, _results;
      this.log('inject', dependencies);
      Assert.ok(dependencies instanceof Array && dependencies.length > 0, 'Dependencies have to be a non-empty list of dependencies');
      _results = [];
      for (_i = 0, _len = dependencies.length; _i < _len; _i++) {
        dependency = dependencies[_i];
        resolvers = this.dependants[dependency] || [];
        resolved = [];
        for (_j = 0, _len1 = resolvers.length; _j < _len1; _j++) {
          resolver = resolvers[_j];
          if (resolver.is_resolved) {
            this.log("Resolver (" + resolver.name + ") already resolved");
            resolved.push(resolver);
          } else {
            resolver_context = {};
            resolver_dependencies = [];
            _ref = resolver.dependencies;
            for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
              resolver_dependency_name = _ref[_k];
              resolver_dependency = this.dependencies[resolver_dependency_name];
              if (resolver_dependency != null) {
                resolver_context[resolver_dependency_name] = resolver_dependency;
                resolver_dependencies.push(resolver_dependency);
              }
            }
            if (resolver_dependencies.length === resolver.dependencies.length) {
              resolved.push(resolver);
              resolver.is_resolved = true;
              resolver.apply(resolver_context, resolver_dependencies);
            }
          }
        }
        _results.push(this.dependants[dependency] = _(resolvers).without(resolved));
      }
      return _results;
    };

    return DependencyInjection;

  })();

  module.exports = DependencyInjection;

}).call(this);
